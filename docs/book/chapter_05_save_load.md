# Chapter 5: Save and Load - Making Progress Persistent

## The Problem: Losing Everything

You've built an explorable world with locations, items, and NPCs. You can move around, look at things, and interact with the environment. But here's a critical issue:

**If you quit the game, you lose everything.**

Your progress - where you were, what you picked up, which NPCs you talked to - **all gone**.

This isn't just annoying. It makes the game fundamentally unplayable. Imagine playing an RPG where you can't save:
- Found a rare item? Better not quit.
- Made it halfway across the map? Hope you have time to finish.
- Need to close your laptop? Start over tomorrow.

**The solution:** Save the game state to disk, and restore it when the player returns.

---

## What Needs to Be Saved?

Before we code, let's think about what "game state" actually means.

**Right now, your game has:**
- **Player's current location** - Where they are in the world
- **Player's inventory** - What items they've collected
- **Location items** - Which items are still in each location (some might have been picked up)

---

**‚ö†Ô∏è CRITICAL WARNING: The #1 Save/Load Bug**

**THE PROBLEM:** If you only save player data (location + inventory) and forget to save location items, **items will respawn every time you load the game!**

**Why it happens:**
1. Player picks up wooden_branch from village
2. You save: current_location and inventory
3. Game quits
4. Game restarts and reloads locations from YAML (fresh, original state!)
5. wooden_branch is back in the village (it respawned!)

**This is the most common save/load bug in game development.** You MUST save the current state of location items, not just reload them from YAML.

We'll handle this properly in the code below. But be warned: forgetting this step will waste hours of debugging!

---

**Later, you'll also save:**
- Quest progress
- NPC dialogue state
- Character stats
- Discovered locations
- Time played

**The key insight:** Save files are just **snapshots of your game's variables** at a moment in time.

---

## Concept: JSON for Game Saves

**What is JSON?**

JSON (JavaScript Object Notation) is a text format for storing structured data. It looks a lot like Python dictionaries:

```json
{
  "current_location": "village_entrance",
  "inventory": ["wooden_branch", "small_health_potion"],
  "location_items": {
    "village_entrance": ["gold_coin"],
    "town_square": []
  }
}
```

**Why JSON for saves?**

‚úÖ **Human-readable** - You can open a save file and understand it

‚úÖ **Built into Python** - No extra libraries needed

‚úÖ **Cross-platform** - Works on Windows, Mac, Linux

‚úÖ **Editable** - Players can even manually fix corrupted saves

‚ùå **Not secure** - Players can cheat by editing files (but that's okay for single-player!)

### JSON vs YAML

You might wonder: "We use YAML for game content, why JSON for saves?"

**YAML is for content** (designed by humans, rarely changes):
- Locations, items, NPCs
- Quest definitions
- Character data

**JSON is for state** (generated by code, changes frequently):
- Save files
- Player progress
- Dynamic game state

Both work, but JSON is the standard for save files in games.

---

## Concept: Serialization

**Serialization** means converting Python objects (like dictionaries, lists) into a format that can be saved to a file.

**Deserialization** means converting that file data back into Python objects.

```python
import json

# Python dictionary (in memory)
data = {"name": "Alice", "level": 5}

# Serialize to JSON string
json_string = json.dumps(data)
# Result: '{"name": "Alice", "level": 5}'

# Deserialize back to Python dict
restored_data = json.loads(json_string)
# Result: {"name": "Alice", "level": 5}
```

**Key functions:**
- **`json.dumps(obj)`** - Convert Python object to JSON string
- **`json.loads(string)`** - Convert JSON string to Python object
- **`json.dump(obj, file)`** - Write Python object directly to file
- **`json.load(file)`** - Read Python object directly from file

---

## Challenge 1: The Save Command

Let's implement the ability to save the game.

### Step 1: Plan the Save Data Structure

What do we need to save? Let's start simple:

```python
save_data = {
    "version": "0.0.1",           # Track save format version
    "current_location": "village_entrance",
    "inventory": ["wooden_branch"]
}
```

**Why include version?** Future versions of your game might save more data. The version number helps you handle old save files gracefully.

**Note:** Right now we're using simple variables (`current_location`, `inventory`). Later in the book, these will move into a Player class (`player.current_location`, `player.inventory`). The save/load logic remains the same - you're just saving/loading object attributes instead of standalone variables.

### Step 2: Create the Save Directory

First, let's make sure we have a place to store saves:

```bash
mkdir -p data/saves
```

### Step 3: Implement the Save Function

Create a new file: `src/helpers/save_load.py`

**Skeleton:**

```python
import json
import os

def save_game(player, locations, console, settings):
    """
    Save the current game state to a JSON file.

    Args:
        player: Player object with current_location and inventory
        locations: Dictionary of all location data
        console: Rich console for output
        settings: Game settings dictionary
    """

    # TODO: Create the saves directory if it doesn't exist
    # Hint: os.makedirs("data/saves", exist_ok=True)


    # TODO: Build a dictionary of items in each location
    # Why? Because items might have been picked up, we need to save
    # the CURRENT state, not the original YAML data

    location_items = {}
    # Loop through all locations
    # for location_id, location_data in locations.items():
    #     location_items[location_id] = location_data["items"]


    # TODO: Build the save data dictionary
    save_data = {
        "version": "0.0.1",
        # Add current_location
        # Add inventory
        # Add location_items
    }


    # TODO: Write to file
    # Hint: with open("data/saves/savegame.json", "w") as file:
    #           json.dump(save_data, file, indent=2)
    # The indent=2 makes the file human-readable


    # TODO: Show success message
    # console.print("[green]Game saved successfully![/green]")
```

### Step 4: Call the Save Function

In `main.py`, add the save command to your game loop:

```python
# At the top, import the save function
from src.helpers.save_load import save_game

# In your game loop, after other commands:

elif action == "save":
    # TODO: Call save_game with the right parameters
    # Hint: save_game(player, locations, console, settings)

```

### Guiding Questions

**Q1: Why do we need to save location_items separately?**

<details>
<summary>Hint</summary>

Think about what happens when you pick up an item:
1. It's removed from `location["items"]`
2. It's added to `player.inventory`

If we reload locations from YAML, they'll have their original items again! We need to save the **current** item state, not the original.

Example:
- Original YAML: `items: [wooden_branch, gold_coin]`
- Player takes wooden_branch
- Current state: `items: [gold_coin]`
- If we don't save this, reloading brings back the wooden_branch!
</details>

**Q2: What does `indent=2` do in json.dump?**

<details>
<summary>Hint</summary>

Compare:

**Without indent:**
```json
{"current_location":"village_entrance","inventory":["wooden_branch"]}
```

**With indent=2:**
```json
{
  "current_location": "village_entrance",
  "inventory": [
    "wooden_branch"
  ]
}
```

Much more readable! The number controls how many spaces to indent.
</details>

**Q3: Why use `exist_ok=True` in makedirs?**

<details>
<summary>Hint</summary>

Without it, if the directory already exists, you get an error:

```python
os.makedirs("data/saves")  # First time: works
os.makedirs("data/saves")  # Second time: ERROR! Directory exists

os.makedirs("data/saves", exist_ok=True)  # Always works
```

It means: "Create this directory if it doesn't exist. If it does exist, that's fine."
</details>

---

## Challenge 2: The Load Command

Now let's implement loading a saved game.

### The Load Function

Add this to `src/helpers/save_load.py`:

**Skeleton:**

```python
def load_game(player, locations, console, settings):
    """
    Load a saved game from JSON file.

    Returns:
        Dictionary with save data if successful, None if no save exists
    """

    save_path = "data/saves/savegame.json"

    # TODO: Check if save file exists
    # Hint: if not os.path.exists(save_path):
    #           return None


    # TODO: Load the JSON file
    # with open(save_path, "r") as file:
    #     loaded_data = json.load(file)


    # TODO: Restore player state
    # player.current_location = loaded_data["current_location"]
    # player.inventory = loaded_data["inventory"]


    # TODO: Restore location items
    # This is CRITICAL! Without this, items respawn
    # if "location_items" in loaded_data:
    #     for location_id, items in loaded_data["location_items"].items():
    #         if location_id in locations:
    #             locations[location_id]["items"] = items


    # TODO: Show success message
    # console.print("[green]Game loaded successfully![/green]")


    # Return the loaded data
    return loaded_data
```

### Call Load in Main Game

In `main.py`, add the load command:

```python
# Import at top
from src.helpers.save_load import save_game, load_game

# In game loop:

elif action == "load":
    # TODO: Call load_game
    result = load_game(player, locations, console, settings)

    # TODO: If load succeeded, update current_location reference
    # Remember: current_location is a reference to a location in the locations dict
    # if result:
    #     current_location = locations[player.current_location]

    # TODO: If load failed (result is None), show error
    # else:
    #     console.print("[red]No save file found![/red]")
```

### Guiding Questions

**Q1: Why check if the file exists before trying to load it?**

<details>
<summary>Hint</summary>

If you try to open a file that doesn't exist:

```python
with open("nonexistent.json", "r") as file:  # ERROR!
    # FileNotFoundError: No such file or directory
```

Better to check first and show a user-friendly message:

```python
if not os.path.exists("nonexistent.json"):
    print("No save file found!")
    return None
```
</details>

**Q2: Why do we need to update both player.current_location AND the current_location variable?**

<details>
<summary>Hint</summary>

Two separate things need updating:

1. **`player.current_location`** - String ID like "village_entrance"
2. **`current_location`** - Reference to the actual location dictionary

After loading:
```python
player.current_location = "town_square"  # Load saved location ID
current_location = locations[player.current_location]  # Get the actual dict
```

Now when you do `current_location["name"]`, you get the right location!
</details>

**Q3: What happens if location_items isn't in the save data?**

<details>
<summary>Hint</summary>

Old save files might not have this field (if you add it in a later version). That's why we check:

```python
if "location_items" in loaded_data:
    # Restore items
```

If it's not there, we skip restoring items. Locations will have their default items from YAML.

This is **backward compatibility** - new game versions work with old save files.
</details>

---

## Challenge 3: Testing Save/Load

Time to test your implementation thoroughly!

### Test Plan

**Test 1: Basic save and load**
1. Start game
2. Note your starting location (e.g., Village Entrance)
3. Type `save`
4. Type `quit`
5. Restart the game
6. Type `load`
7. ‚úÖ You should be at Village Entrance

**Test 2: Inventory persistence**
1. Pick up an item: `take wooden branch`
2. Check inventory: `inventory`
3. Type `save`
4. Type `quit`
5. Restart game
6. Type `load`
7. Type `inventory`
8. ‚úÖ Wooden Branch should still be in your inventory

**Test 3: Items don't respawn (‚ö†Ô∏è THIS IS THE CRITICAL TEST!)**

This tests whether you properly saved location_items. If this fails, you have the respawning bug!

1. Go to a location with an item
2. Type `look` - note the item is there
3. Type `take [item]`
4. Type `look` - item should be gone
5. Type `save`
6. Type `quit`
7. Restart game
8. Type `load`
9. Type `look`
10. ‚úÖ Item should STILL be gone (not respawned!)

**If the item respawned:** You forgot to restore location_items in your load function! Go back and check the "Restore location items" section.

**Test 4: Movement persistence**
1. Type `go north` (move to a different location)
2. Type `save`
3. Type `quit`
4. Restart
5. Type `load`
6. ‚úÖ You should be in the location you moved to (not starting location)

**Test 5: Load without save file**
1. Delete `data/saves/savegame.json` (or rename it)
2. Start game
3. Type `load`
4. ‚úÖ Should show error message (not crash)

---

## Understanding the Data Flow

Let's trace what happens during save and load:

### Save Flow

```
1. Player types "save"
2. Collect current state:
   - player.current_location = "town_square"
   - player.inventory = ["wooden_branch"]
   - locations["village_entrance"]["items"] = ["gold_coin"]
3. Build save_data dictionary
4. Serialize to JSON:
   {
     "current_location": "town_square",
     "inventory": ["wooden_branch"],
     "location_items": {
       "village_entrance": ["gold_coin"],
       ...
     }
   }
5. Write to data/saves/savegame.json
```

### Load Flow

```
1. Player types "load"
2. Check if savegame.json exists
3. Read file
4. Deserialize JSON to Python dict
5. Restore state:
   - player.current_location = loaded_data["current_location"]
   - player.inventory = loaded_data["inventory"]
   - For each location, restore its items list
6. Update current_location reference
7. Player is back where they were!
```

**Key insight:** Loading doesn't create new objects - it **modifies existing ones** to match the saved state.

---

## Extension: The Settings System

Your game might also want to save **settings** - things like:
- Text width
- Color preferences
- Sound volume (if you add sound later)

Settings are different from save data:
- **Saves** are per-playthrough (different characters, different progress)
- **Settings** are per-player (apply to all playthroughs)

### Challenge: Implement Settings Save/Load

Create `data/settings.json` with default settings:

```json
{
  "text_width": 100,
  "color_scheme": "default",
  "show_tips": true
}
```

**Your task:**
1. Load settings at game startup
2. Add a `settings` command to change them
3. Save settings when changed
4. Apply settings (like text width for Rich console)

**Skeleton:**

```python
def load_settings():
    """Load game settings from JSON"""
    if os.path.exists("data/settings.json"):
        with open("data/settings.json", "r") as file:
            return json.load(file)
    else:
        # Return default settings
        return {
            "text_width": 100,
            "color_scheme": "default",
            "show_tips": True
        }

def save_settings(settings):
    """Save game settings to JSON"""
    # TODO: Similar to save_game, but write to data/settings.json
```

---

## Common Mistakes

### Mistake 1: Forgetting to save location items

```python
# WRONG - only saves player data
save_data = {
    "current_location": player.current_location,
    "inventory": player.inventory
}
# Items will respawn on load!

# RIGHT - saves location states too
save_data = {
    "current_location": player.current_location,
    "inventory": player.inventory,
    "location_items": {loc_id: loc["items"] for loc_id, loc in locations.items()}
}
```

### Mistake 2: Not updating current_location reference after load

```python
# WRONG
def load_game(player, locations):
    player.current_location = loaded_data["current_location"]
    # current_location in main.py is now stale!

# RIGHT - also return the loaded data so main.py can update its reference
def load_game(player, locations):
    player.current_location = loaded_data["current_location"]
    return loaded_data  # Let caller update their reference
```

### Mistake 3: Overwriting the wrong file

```python
# WRONG - overwrites location YAML
with open(f"data/locations/{player.current_location}.yaml", "w") as file:
    json.dump(save_data, file)

# RIGHT - writes to saves directory
with open("data/saves/savegame.json", "w") as file:
    json.dump(save_data, file)
```

### Mistake 4: Not handling missing save file

```python
# WRONG - crashes if no save exists
with open("data/saves/savegame.json", "r") as file:
    loaded_data = json.load(file)
# FileNotFoundError!

# RIGHT - check first
if os.path.exists("data/saves/savegame.json"):
    with open("data/saves/savegame.json", "r") as file:
        loaded_data = json.load(file)
else:
    console.print("No save file found!", style="red")
```

---

## Debugging Corner

### Error: `FileNotFoundError: data/saves/savegame.json`

**Cause:** Trying to load a save that doesn't exist.

**Fix:** Check if file exists before trying to open it:

```python
if os.path.exists(save_path):
    # Load
else:
    # Handle no save
```

### Error: `json.decoder.JSONDecodeError`

**Cause:** Save file is corrupted or not valid JSON.

**Common reasons:**
- File was manually edited and has syntax errors
- Write operation was interrupted
- Used `yaml.dump()` instead of `json.dump()`

**Debug:**
```bash
# View the save file
cat data/saves/savegame.json

# Check if it's valid JSON
python -m json.tool data/saves/savegame.json
```

**Fix:** Delete the corrupted save and create a new one.

### Bug: Items respawn after loading

**Cause:** Not restoring location items from save data.

**Fix:** Make sure you have this in load_game:

```python
if "location_items" in loaded_data:
    for location_id, items in loaded_data["location_items"].items():
        if location_id in locations:
            locations[location_id]["items"] = items
```

### Bug: After loading, look shows wrong location

**Cause:** current_location reference wasn't updated.

**In main.py after calling load_game:**

```python
result = load_game(player, locations, console, settings)
if result:
    # THIS IS CRITICAL
    current_location = locations[player.current_location]
```

---

## What You've Learned

‚úÖ **JSON serialization** - Converting Python objects to/from JSON

‚úÖ **File I/O** - Reading and writing files

‚úÖ **State management** - Capturing and restoring game state

‚úÖ **Data persistence** - Making progress survive game restarts

‚úÖ **Directory operations** - Creating directories programmatically

‚úÖ **Error handling** - Checking if files exist before accessing them

‚úÖ **Backward compatibility** - Handling old save formats

‚úÖ **Critical bug awareness** - Items respawning is a common save/load issue

---

## Looking Ahead

**Milestone 0 Complete!** üéâ

You now have:
- ‚úÖ A world you can explore (locations with exits)
- ‚úÖ NPCs you can interact with
- ‚úÖ Items you can find and inspect
- ‚úÖ Validation to catch content errors
- ‚úÖ **Save/load so progress persists**

**In Chapter 6**, you'll begin Milestone 1 - bringing your world to life with:
- Dialogue trees (branching conversations)
- Quest system (objectives and rewards)
- Inventory improvements (use items, weight limits)

**In Chapter 11**, you'll add character creation:
- Races (Human, Elf, Dwarf, Orc)
- Classes (Warrior, Mage, Rogue)
- Stats system
- Character sheet

Your game is becoming **real**.

---

## Extension Ideas

### Extension 1: Multiple Save Slots

Instead of one `savegame.json`, allow multiple saves:

```
data/saves/
  save1.json
  save2.json
  save3.json
```

**Commands:**
- `save 1` - Save to slot 1
- `load 2` - Load from slot 2
- `saves` - List all saves with timestamps

**Hint:** Use `parts[1]` to get the slot number:

```python
elif action == "save":
    if len(parts) >= 2:
        slot = parts[1]
        save_path = f"data/saves/save{slot}.json"
```

### Extension 2: Autosave

Automatically save every N turns or on important events:

```python
turn_counter = 0

# In game loop
turn_counter += 1
if turn_counter % 10 == 0:  # Every 10 turns
    save_game(player, locations, console, settings, autosave=True)
```

Show a subtle indicator: `[dim]Game auto-saved[/dim]`

### Extension 3: Save File Metadata

Include extra info in save files:

```python
import time

save_data = {
    "version": "0.0.1",
    "timestamp": time.time(),
    "play_time_seconds": 3600,
    "character_name": player.name,
    "character_level": player.level,
    # ... rest of save data
}
```

Then when listing saves:

```
Saves:
  1. Alice (Level 5) - 2 hours ago
  2. Bob (Level 3) - 1 day ago
```

### Extension 4: Cloud Saves

Save to a remote server so players can play on multiple devices:

```python
import requests

def cloud_save(save_data, player_id):
    response = requests.post(
        "https://yourgame.com/api/save",
        json={
            "player_id": player_id,
            "save_data": save_data
        }
    )
```

**Note:** This requires a backend server (advanced topic for later).

---

## Chapter 5 Checklist

Before moving on, make sure you can:

- [ ] Explain what serialization means
- [ ] Use `json.dump()` to write data to a file
- [ ] Use `json.load()` to read data from a file
- [ ] Check if a file exists with `os.path.exists()`
- [ ] Create directories with `os.makedirs()`
- [ ] Save player state (location, inventory)
- [ ] Save location state (items)
- [ ] Restore state when loading
- [ ] Update references after loading
- [ ] Handle missing save files gracefully
- [ ] Test that items don't respawn

**All checked?** You've completed Milestone 0! üéÆ

---

## Final Thoughts

Save/load is one of those features that seems simple but has **subtle gotchas**. The "items respawning" bug is especially insidious - the game appears to work fine until you realize your carefully collected items keep reappearing in locations.

**This teaches an important lesson in game development:**

> **State lives in multiple places. You must save ALL of it.**

Think about other places state lives in your game:
- Which NPCs you've talked to
- Which quests you've started
- Which enemies you've defeated
- Which doors you've unlocked

Each of these will need to be saved too. As your game grows, your save file grows with it.

**Professional games** have entire systems for managing saves:
- Version migration (updating old saves to new formats)
- Compression (large games = large saves)
- Validation (detecting corrupted saves)
- Cloud sync (multiple devices)

You're learning the foundations of these systems right now.

**Next:** In Chapter 6, we'll make NPCs actually talk back with a dialogue tree system!

---

*"Remember to save your game - and your code!"* - Every Developer Ever
